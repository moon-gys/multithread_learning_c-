## C++并发的世界

## 2 线程管理

### 2.1 线程管理的基础

每个程序至少有一个线程：执行main()函数的线程，其余线程尤其各自的入口，线程与原始线程（以main为入口的函数）同时运行。

#### 2.1.1 启动线程

使用C++线程库启动线程，归结为构造std::thread对象；（thread本身就是一个class）

#### 2.1.2 等待线程完成 

thread_name.join():简单粗暴地等待线程完成或不等待。若需要对等待的线程有更灵活的控制时，比如看一下某个线程是否结束或只等待一段时间，需要使用其他机制来完成：条件变量或者futures。

#### 2.1.3 特殊情况下的等待



#### 2.1.4 后台运行线程

## 3 线程间共享数据

**主要内容**
- 共享数据带来的问题
- 使用互斥量保护数据
- 数据保护的替代方案

### 3.1 共享数据带来的问题

线程间涉及到共享数据的潜在问题： 修改共享数据，结果并行代码常见错误---条件竞争。

**条件竞争**

并发中条件竞争的形成，取决于一个以上线程的相对执行顺序，每个线程都抢着完成自己的任务。c++中一种特殊的条件竞争：并发的去修改一个独立的对象。

恶性条件竞争通常发生于对多于一个数据快进行修改时，例如删除双链表中一个节点要对两个连接指针进行修改，因为操作要访问两个独立的数据块,独立的指令将会对数据块进行修改，并且其中一个线程可能正在进行时，另一个线程就对数据块进行了访问。因为出现的概率太低，条件竞争很难查找，也很难复现。
条件竞争通常是时间敏感的，所以程序以调试模式运行时，他们通常会完全消息，因为调试模式会影响程序的执行时间。

**避免恶性条件竞争**

1. 对数据结构采取某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态从其他线程角度来看，修改不是已经完成了，就是还没开始。
2. 无锁编程：对数据结构和不变量的设计进行修改，修改完的结构必须完成一系列不可分割的变化，也就是保证每个不变量保持稳定的状态-----这种方式很难得到正确的结果。
3. 事务的方式处理数据结构的更新。（被称为软件事务内存，理论研究中）

### 3.2 使用互斥量保护共享数据

#### 3.2.1 c++中使用互斥量

当一个线程使用特定的互斥量锁住共享数据时，其他线程想要访问锁住的数据，都必须等到之前那个线程对数据解锁后才能访问。

但互斥量自身也有问题，会造成死锁或者对数据保护太多或者太少；

EX: mutex_thread.cpp
```
std::list<int> some_list;
std::mutex some_mutex;

void add_to_list(int new_value)
{
	//构造时自动加锁
   std::lock_guard < std::mutex> guard(some_mutex);
	 some_list.push_back(new_value);

  //离开作用域，析构函数自动完成解锁功能
}

bool list_contains(int value_to_find)
{
    std::lock_guard<std::mutex> guard(some_mutex);
	  return std::find(some_list.begin(), some_list.end(), value_to_find) != some_list.end();
}
```

c++ 中通过实例化std::mutex创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。
  - 不推荐直接是调用成员函数，若直接调用，必须记住每个函数的出口都要去调用unlock(),也包括异常的情况，

C++标准库提供了一个RAII语法的模板类std::lock_guard, 其会在构造的时候提供已锁的互斥量，析构的时候进行解锁，从而保证了以锁的互斥量总是会被正确的解锁。

大多数情况下，互斥量通常会与保护的数据放在同一个类中。这是面向对象设计的准则：将其放在同一个类中，就可以让他们联系到一起，也可对类的功能进行封装，并进行数据保护。互斥量和要保护的数据，在类中都需要定义为private成员，这会让访问数据的代码变的清晰，并且容易看出在什么时候对互斥量上锁。当所有成员函数都会在调用时对数据上锁，结束时对数据解锁，那么就保证了数据访问时不变量不被破坏。

**当其中一个成员函数返回的是保护数据的指针或引用时，会破坏对数据的保护。具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。互斥量保护的数据需要对接口的设计相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且不留后门。原因如下：**

**实现my_lock_guard**
```
namespace myspace {
    template<typename T> class my_lock_guard {
    public:
        // 在 std::mutex 的定义中，下面两个函数被删除了
        // mutex(const mutex&) = delete;
        // mutex& operator=(const mutex&) = delete;
        // 因此这里必须传递引用
        my_lock_guard(T& mutex) :mutex_(mutex){
            // 构造加锁
            mutex_.lock();
        }
 
        ~my_lock_guard() {
            // 析构解锁
            mutex_.unlock();
        }
    private:
        // 不可赋值，不可拷贝
        my_lock_guard(my_lock_guard const&);
        my_lock_guard& operator=(my_lock_guard const&);
    private:
        T& mutex_;
    };
 
};
 
```

lock_guard 只是一个包装类，而实际的加锁和解锁的操作都还是 std::mutex 完成的.

std::mutex 是一个保护共享数据不会被多个线程同时访问的类，叫做互斥量，可以看作是一把锁。用法：
```
#include <mutex>
 
std::mutex kMutex;
 
void function() {
  //加锁
  kMutex.lock();
  //kMutex.try_lock();
 
  //do something that is thread safe...
  
  // 离开作用域解锁
  kMutex.unlock();
}
```
#### 3.2.2 精心组织代码来保护数据

一个迷失的指针或引用，会让使用互斥量保护数据形同虚设。但是只要成员函数不要向其调用者返回指向受保护的数据的指针或引用，数据就是安全的。

在确保成员函数不会传出指针或引用的同时，检查成员函数是否通过指针或引用的方式来调用也是很重要的。
- 函数可能没在互斥量保护的区域内，存储着指针或引用，这样就很危险；
- 将保护数据作为一个运行时参数，更危险。

#### 3.2.3 发现接口内在的条件竞争

使用互斥量或其他机制保护了共享数据，仍然需要担心条件竞争。
  - 双链表的例子，为了能让线程安全地删除一个节点，需要确保防止对这三个节点(待删除的节点及其前后相邻的节点)的并发访问。如果只对指向每个节点的指针进行访问保护，那就和没有使用互斥量一样，条件竞争仍会发生——除了指针，整个数据结构和整个删除操作需要保护。这种情况下最简单的解决方案就是使用互斥量来保护整个链表
 




## 同步并发操作

## c++内存模型和原子类型操作

## 基于锁的并发数据结构设计

## 无锁的并发数据结构设计

## 并发代码设计

## 高级线程管理

## 多线程程序的测试和调试
